// --------------------------------------------------------------------------------------------------------------------
// <copyright file="settingsEntriesForObject.cs" company="imbVeles" >
//
// Copyright (C) 2018 imbVeles
//
// This program is free software: you can redistribute it and/or modify
// it under the +terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see http://www.gnu.org/licenses/. 
// </copyright>
// <summary>
// Project: imbSCI.Core
// Author: Goran Grubic
// ------------------------------------------------------------------------------------------------------------------
// Project web site: http://blog.veles.rs
// GitHub: http://github.com/gorangrubic
// Mendeley profile: http://www.mendeley.com/profiles/goran-grubi2/
// ORCID ID: http://orcid.org/0000-0003-2673-9471
// Email: hardy@veles.rs
// </summary>
// ------------------------------------------------------------------------------------------------------------------
namespace imbSCI.Core.data
{
    using imbSCI.Core.collection;
    using imbSCI.Core.extensions.data;
    using imbSCI.Core.extensions.text;

    //using imbSCI.Core.extensions.text;
    using imbSCI.Core.extensions.typeworks;
    using imbSCI.Core.math;
    using imbSCI.Data.collection.nested;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Linq;
    using System.Reflection;
    using System.Text;

    /// <summary>
    /// View data model - for representation of an Object and its Type in GUI, TUI or autogenerated description, user manual and
    /// </summary>
    public class settingsEntriesForObject : INotifyPropertyChanged
    {
        private String _id;

        /// <summary>
        ///
        /// </summary>
        public String id
        {
            get { return _id; }
            protected set { _id = value; }
        }

        /// <summary>
        /// Name of this type/class - if not specified then uses normal type name
        /// </summary>
        /// <value>
        /// The display name.
        /// </value>
        public String DisplayName => TypeInfo?.displayName;

        public String Description => TypeInfo?.description;

        public String Category => TypeInfo?.categoryName;

        public List<String> additionalInfo => TypeInfo?.additionalInfo;

        public String info_link => TypeInfo?.info_link;

        public String info_helpTips => TypeInfo?.info_helpTips;

        public String info_helpTitle => TypeInfo?.info_helpTitle;

        public List<String> CategoryByPriority => TypeInfo.CategoryByPriority;

        public String color => TypeInfo?.color;

        private static aceConcurrentDictionary<settingsEntriesForObject> _registry;

        /// <summary>
        /// static and autoinitiated object
        /// </summary>
        internal static aceConcurrentDictionary<settingsEntriesForObject> registry
        {
            get
            {
                if (_registry == null)
                {
                    _registry = new aceConcurrentDictionary<settingsEntriesForObject>();
                }
                return _registry;
            }
        }

        /// <summary>
        /// Generise meta model za prosledjeni tip
        /// </summary>
        /// <param name="target"></param>
        public settingsEntriesForObject(Type type, Boolean includeCollectionItems)
        {
            id = type.FullName + includeCollectionItems.ToString();
            targetType = type;
            if (registry.ContainsKey(id))
            {
                DeployFromRegistry(id);
            }
            else
            {
                processType(type, includeCollectionItems, null);
                registry.Add(id, this);
            }
        }

        protected void DeployFromRegistry(String id)
        {
            this.pis = registry[id].pis;
            this.spes = registry[id].spes;
            this.pce = registry[id].pce;
            TypeInfo = registry[id].TypeInfo;
        }

        /// <summary>
        /// Generise meta model za prosledjeni objekat
        /// </summary>
        /// <param name="target"></param>
        public settingsEntriesForObject(Object target, Boolean includeCollectionItems = false, Boolean useCached = true)
        {
            if (target == null) throw new ArgumentNullException("target"); //new aceGeneralException("Target is null", null, this, "settingsEntriesForObject-> target null");
            id = target.GetType().FullName + includeCollectionItems.ToString();
            targetType = target.GetType();

            if (registry.ContainsKey(id) && useCached)
            {
                DeployFromRegistry(id);
            }
            else
            {
                processObject(target, false);
                if (useCached) registry.Add(id, this);
            }
        }

        private Type _targetType;

        /// <summary>
        /// Reference to the type that is being processed
        /// </summary>
        public Type targetType
        {
            get
            {
                return _targetType;
            }
            set
            {
                _targetType = value;
                OnPropertyChanged("targetType");
            }
        }

        private PropertyCollectionExtended _pce;

        /// <summary> </summary>
        public PropertyCollectionExtended pce
        {
            get
            {
                return _pce;
            }
            protected set
            {
                _pce = value;
                OnPropertyChanged("pce");
            }
        }

        /// <summary>
        /// Sorts the property.
        /// </summary>
        /// <param name="a">a.</param>
        /// <param name="b">The b.</param>
        /// <returns></returns>
        private Int32 SortProperty(PropertyInfo a, PropertyInfo b)
        {
            if (a == null) return -1;
            if (b == null) return 1;
            if (a == b) return 0;

            //a.DeclaringType.ty

            if (a.DeclaringType == targetType)
            {
                return -1;
            }
            return 1;
        }

        /// <summary>
        /// Hashed type signature
        /// </summary>
        /// <returns></returns>
        public String GetSignature()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(targetType.Name).Append((string)spes.Keys.ToList().toCsvInLine()); //.toCsvInLine());
            return md5.GetMd5Hash(sb.ToString());
        }

        /// <summary>
        /// Information on the type level
        /// </summary>
        /// <value>
        /// The type information.
        /// </value>
        public settingsMemberInfoEntry TypeInfo { get; set; }

        /// <summary>
        /// Processes the type.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="includeCollectionItems">if set to <c>true</c> [include collection items].</param>
        /// <param name="target">The target.</param>
        protected void processType(Type type, Boolean includeCollectionItems, Object target = null, Int32 call = 0)
        {
            targetType = type;

            TypeInfo = new settingsMemberInfoEntry(type);

            var pTypes = type.GetBaseTypeList(false, true, null, call++);

            pTypes.Add(type);

            List<PropertyInfo> props = new List<PropertyInfo>();
            foreach (var t in pTypes)
            {
                var pr = t.GetProperties(BindingFlags.Public | BindingFlags.DeclaredOnly | BindingFlags.Instance);
                props.AddRange(pr);
            }

            List<PropertyInfo> propList = new List<PropertyInfo>();
            foreach (PropertyInfo pro in props)
            {
                if (pro.CanWrite)
                {
                    if (pro.PropertyType.IsEnum)
                    {
                        propList.Add(pro);
                    }
                    else if (pro.PropertyType.IsPrimitive)
                    {
                        propList.Add(pro);
                    }
                    else if (pro.PropertyType == typeof(String))
                    {
                        propList.Add(pro);
                    }
                    else
                    {
                        if (pro.DeclaringType == targetType)
                        {
                            if (pro.Name != "Item")
                            {
                                propList.Add(pro);
                            }
                            else
                            {
                            }
                        }
                    }
                }
            }

            //  propList.Sort(SortProperty);

            foreach (PropertyInfo pro in propList)
            {
                if (!pis.ContainsKey(pro.Name))
                {
                    pis.Add(pro.Name, pro);

                    settingsPropertyEntryWithContext spe = new settingsPropertyEntryWithContext(pro, target, pce);
                    spes.Add(pro.Name, spe);
                }
            }

            if (includeCollectionItems)
            {
                if (target is IList)
                {
                    IList l = target as IList;

                    foreach (var i in l)
                    {
                        settingsPropertyEntryWithContext spe = new settingsPropertyEntryWithContext(i, l, pce);
                        spes.Add(spe.displayName, spe);
                    }
                }
            }

            //// SORTING
            List<settingsPropertyEntryWithContext> tempList = new List<settingsPropertyEntryWithContext>();

            // SORTING BY CATEGORY
            if (CategoryByPriority.Count > 0)
            {
                //aceDictionarySet<String, settingsPropertyEntry> pi_set = new aceDictionarySet<string, settingsPropertyEntry>();
                Int32 pri = CategoryByPriority.Count;

                foreach (String cat in CategoryByPriority)
                {
                    IEnumerable<settingsPropertyEntryWithContext> propInCat = spes.Values.Where(x => x.categoryName.ToLower() == cat.ToLower());
                    foreach (settingsPropertyEntryWithContext pic in propInCat)
                    {
                        pic.priority = (CategoryPrioritySpaceSize * pri) + pic.priority;
                        tempList.Add(pic);
                    }
                    pri--;
                }

                foreach (var pair in spes)
                {
                    if (!tempList.Contains(pair.Value))
                    {
                        if (!CategoryByPriority.Contains(pair.Value.categoryName))
                        {
                            CategoryByPriority.Add(pair.Value.categoryName);
                        }
                        tempList.Add(pair.Value);
                    }
                }
            }
            else
            {
                foreach (settingsPropertyEntryWithContext pic in spes.Values)
                {
                    tempList.Add(pic);
                }
            }

            // DEPLOYING PRIORITY SETTINGS INTO INDEX
            tempList = tempList.OrderByDescending(x => x.priority).ToList();

            spes.Clear();
            Int32 index = 0;
            foreach (var pic in tempList)
            {
                pic.index = index;
                index++;
                spes.Add(pic.name, pic);
            }

            // INHERITS MISSING VALUES
            foreach (var pair in spes)
            {
                inheritMissingSettings(pair.Value);
            }
        }

        public const Int32 CategoryPrioritySpaceSize = 1000;

        /// <summary>
        /// Inherit default values from parent type, for some settings like color
        /// </summary>
        /// <param name="sME">The s me.</param>
        protected void inheritMissingSettings(settingsMemberInfoEntry sME)
        {
            if (TypeInfo == sME) return;

            if (sME.color.isNullOrEmpty()) sME.color = color;
        }

        /// <summary>
        /// Ucitava objekat u sebe i postavlja sve definicije
        /// </summary>
        /// <param name="target"></param>
        protected void processObject(Object target, Boolean includeCollectionItems)
        {
            targetType = target.GetType();
            processType(targetType, includeCollectionItems, target);
        }

        /// <summary>
        /// Sets contextual data back into object instance, or creates new instance if <c>target</c> is null
        /// </summary>
        /// <param name="target"></param>
        /// <returns></returns>
        public Object valueToObject(Object target)
        {
            if (target == null)
            {
                target = targetType.getInstance();
            }
            foreach (var spe in spes)
            {
                if (spe.Value.index > -1)
                {
                    IList l = target as IList;
                    if (spe.Value.index >= l.Count)
                    {
                        l.Add(spe.Value.value);
                    }
                    else
                    {
                        l[spe.Value.index] = spe.Value.value;
                    }
                }
                else
                {
                    target.imbSetPropertySafe(spe.Value.pi, spe.Value.value);
                }
            }
            return target;
        }

        public Dictionary<String, PropertyInfo> pis = new Dictionary<string, PropertyInfo>();

        private Dictionary<String, settingsPropertyEntryWithContext> _spes =
            new Dictionary<string, settingsPropertyEntryWithContext>();

        /// <summary>
        /// settings entries with context
        /// </summary>
        public Dictionary<String, settingsPropertyEntryWithContext> spes
        {
            get
            {
                return _spes;
            }
            protected set
            {
                _spes = value;
                OnPropertyChanged("spes");
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}